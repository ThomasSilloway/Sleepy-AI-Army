# Specification: Cleanup of Secretary Output File

## 1. Problem Definition

The file specified by `app_config.secretary_output_file_path` (which corresponds to `ai-goals/new-goal-folders.txt` or similar, depending on configuration) is generated by the Secretary component. This file is then read and processed by the Army General component within its `run()` function in `army-general/src/main.py`. Currently, this output file is not deleted after its contents have been used by the Army General. This can lead to an accumulation of orphaned files, potentially causing confusion, consuming disk space, or interfering with subsequent operations if stale data is unintentionally reused.

## 2. Solution Definition

The A+ solution detailed in `ai-docs/planning/04_cleanup-new-goal-folders/critique.md` will be implemented. This involves modifying the `run()` function in `army-general/src/main.py` to incorporate a robust cleanup mechanism for the `app_config.secretary_output_file_path`.

The core aspects of the solution are:

*   **Responsibility:** The Army General's `run()` function will be responsible for the cleanup.
*   **Mechanism:** A `try...finally` block will ensure that cleanup is attempted regardless of success or failure of intermediate operations.
*   **Early Variable Definition:** The path to the secretary's output file (`secretary_output_file`) and a success flag for the secretary's execution (`secretary_executed_successfully`) will be defined early in the `run()` function to be accessible within the `finally` block.
*   **Operational Logic in `try`:** All main operations—running the Secretary, checking its success, verifying the existence of its output file, reading the file, and iterating through folders to run the Army Man—will be contained within the `try` block.
*   **Graceful Exits:** If critical errors occur within the `try` block (e.g., Secretary fails, output file not found, output file unreadable), the function will log the error and `return`. The `finally` block will still execute before the function fully exits.
*   **Cleanup Logic in `finally`:**
    *   The `finally` block will first check if the `secretary_output_file` exists using `os.path.exists()`.
    *   If it exists, `os.remove()` will be called to delete it. This call will be wrapped in its own nested `try...except OSError` block to handle specific file deletion errors (e.g., permission issues).
    *   Comprehensive logging will report the outcome of the cleanup attempt: successful deletion, failure during deletion (with error), or file not found at the time of cleanup (which might be a normal scenario if it was never created or already handled).
*   **Module Import:** The `os` module must be imported in `army-general/src/main.py`.

## 3. High-Level Implementation Plan (Sparse Priming Representation)

```spr
File: army-general/src/main.py
Function: run
Task: Implement robust cleanup of app_config.secretary_output_file_path.

BEGIN MODIFICATION
Original Structure (Conceptual):
- Initialize logger, config
- Call _run_secretary()
- Check if secretary output file exists
- Read file and get folders
- Loop through folders:
    - Call _run_army_man(folder)
- Log "Army General finished."

New Structure with Cleanup (Reflecting A+ solution from critique.md):
# Ensure 'import os' is present at the top of the file.

async def run() -> None:
    logger.info("Army General orchestration started.")

    secretary_output_file = app_config.secretary_output_file_path
    secretary_executed_successfully = False # Flag to track Secretary's outcome

    try:
        logger.info("Attempting to run Secretary...")
        if not _run_secretary(): # Assumes _run_secretary() returns bool
            logger.error("Secretary execution failed. Further processing of its output will be skipped.")
            # secretary_executed_successfully remains False
        else:
            secretary_executed_successfully = True
            logger.info("Secretary executed successfully.")

        # Proceed only if Secretary was successful
        if not secretary_executed_successfully:
            logger.warning("Skipping processing of Secretary's output file due to earlier errors.")
            return # Exits run(), 'finally' block will execute.

        logger.info(f"Expecting Secretary output file at: {secretary_output_file}")
        if not os.path.exists(secretary_output_file):
            logger.error(f"Secretary output file does not exist at the expected path: {secretary_output_file}. This might be an issue with Secretary's output generation.")
            return # Exits run(), 'finally' block will execute.

        # Parse the folders from the file
        folders = []
        try: # Nested try for file reading
            with open(secretary_output_file, 'r') as file:
                folders = [line.strip() for line in file if line.strip()]
            logger.info(f"Successfully read and parsed Secretary output file. Found {len(folders)} folders.")
        except Exception as e: # Catch any exception during file open/read
            logger.error(f"Failed to read or parse secretary output file {secretary_output_file}: {e}")
            return # Exits run(), 'finally' block will execute.

        if not folders:
            logger.warning("No folders found in Secretary output. No Army Man tasks to perform.")
            # No need to return; processing will naturally finish, then cleanup.

        num_goals_worked_on = 0
        for folder_index, folder in enumerate(folders):
            logger.info(f"Processing folder {folder_index + 1}/{len(folders)}: {folder}")
            if _run_army_man(folder): # Assumes _run_army_man() returns bool
                num_goals_worked_on += 1
                logger.info(f"Successfully completed Army Man task for folder: {folder}")
            else:
                logger.warning(f"Army Man task failed for folder: {folder}. Continuing with next folder if any.")

        logger.info(f"Completed processing all folders. Total goals worked on: {num_goals_worked_on}/{len(folders)}.")

    finally:
        # Cleanup: Attempt to delete the secretary_output_file.
        # This block executes regardless of exceptions or return statements in the try block.
        logger.info(f"Initiating cleanup of Secretary output file: {secretary_output_file}")
        if os.path.exists(secretary_output_file):
            try:
                os.remove(secretary_output_file)
                logger.info(f"Successfully cleaned up Secretary output file: {secretary_output_file}")
            except OSError as e:
                logger.error(f"Error deleting Secretary output file {secretary_output_file}: {e}. Manual cleanup might be required.")
        else:
            # This is not necessarily an error condition.
            # It could mean Secretary failed before creating it, or it was (unexpectedly) already cleaned.
            logger.info(f"Secretary output file {secretary_output_file} was not found during cleanup. This may be normal if Secretary did not produce it or if it was already handled.")

    logger.info("Army General finished all operations.") # This is after the try-finally structure.
END MODIFICATION
```
